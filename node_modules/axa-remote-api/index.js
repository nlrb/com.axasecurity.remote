'use strict'

const net = require('net');

/*
200: OK
210: Unlocked
211: Strong locked
260: Device info
261: Version
502: Command not implemented
*/

/*
  Settings
    ip; IP address of the LAN/LIN module
    port: port number to open at the ip address
    wakeup: if true, send wakeup character before actual message
    retry: if >1, number of retries to resend a message before failure
*/

class AxaRemote {

  constructor(settings) {
    this.ip = settings.ip || '';
    this.port = settings.port || 23;
    this.wakeup = settings.wakeup || true;
    this.retry = settings.retry || 1; // retry once by default
    this.rxBuffer = '';
    this.responses = [];
    this.id = 0;
  }

  connect() {
    return new Promise((resolve, reject) => {
      this.socket = net.connect({ port: this.port, host: this.ip });

  		this.socket
  			.once('connect', () => {
          resolve();
				})
			  .once('timeout', () => {
  				this.disconnect(() => this.socket && this.socket.destroy())
  				reject(new Error('timeout'));
  			})
  			.once('error', (err) => {
  				this.disconnect(() => this.socket && this.socket.destroy())
  				reject(err);
  			})
  			.on('data', (chunk) => {
  				this.rxBuffer += chunk;
  				this.parseResponse(this.rxBuffer);
  			})
    })
  }

  disconnect() {
    if (this.socket) {
      this.socket.end();
      this.socket.destroy();
    }
  }

  sendCommand(command) {
    return new Promise((resolve, reject) => {
      if (typeof command === 'string' || typeof command === 'object') {
        let id;
        let retries = 0;
        if (typeof command === 'string') {
          id = this.id++;
        } else {
          id = command.id;
          resolve = command.resolve;
          reject = command.reject;
          retries = command.retries + 1;
          command = command.command;
        }
        this.responses.push({ id: id, command: command, resolve: resolve, reject: reject, retries: retries });
        if (this.wakeup === true) {
          this.socket.write('\0'); // wake up
        }
        this.socket.write(command + ':\r\n');
        setTimeout(() => {
          let idx = this.responses.findIndex(elem => elem.id === id);
          if (idx >= 0) {
            // response has not been handled yet
            let response = this.responses[idx];
            this.responses.splice(idx, 1); // remove this response
            this._handleResponseError(response, '<none>', { code: 501, message: 'No response' });
          }
        }, 1500);
      } else {
        reject(new Error('Invalid command'));
      }
    });
  }

  parseResponse(response) {
    if (response != null) {
      let lines = response.split('\r\n');
      //console.log(lines);
      lines.forEach(line => {
        if (line !== '') {
          if (line.slice(-1) === ':' || line === '\0') {
            // Ignore command echo
          } else {
            let result = line.match(/^(\d+) (.+)$/);
            if (this.responses.length > 0) {
              let response = this.responses.pop();
              if (result != null && result.length > 1) {
                let code = Number(result[1]);
                let reply = {
                  command: response.command,
                  code: code,
                  message: result[2]
                };
                if (code < 500) {
                  response.resolve(reply);
                } else {
                  this._handleResponseError(response, code, reply);
                }
              } else {
                this._handleResponseError(response, result, {
                  command: response.command,
                  code: 500,
                  message: lines
                });
              }
            }
          }
        }
      });
      this.rxBuffer = '';
    }
  }

  _handleResponseError(response, result, reply) {
    if (this.retry > 0 && response.retries < this.retry) {
      //console.log('Got response', result, 'starting retry', response.retries);
      this.sendCommand(response);
    } else {
      response.reject(reply);
    }
  }

  checkAxaRemote() {
    return new Promise(async (resolve, reject) => {
      try {
        let result = await this.sendCommand('device');
        resolve((result.code === 260 && result.message === 'AXA RV2900 2.0'));
      } catch (e) {
        reject(e);
      }
    });
  }

}

module.exports = AxaRemote;
